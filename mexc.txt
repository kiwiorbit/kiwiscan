Skip to content
Chat history
You said:
mexc alpha token api kline 
ChatGPT said:
Yes ‚Äî you can get the k-line (candlestick) data for the token Alephium (ALPH) on the exchange MEXC via their Spot V3 API. Here are the details in simple terms for your use (especially since you‚Äôre already using APIs/WebSockets).

‚úÖ What you need
‚Ä¢ Token: ALPH (on MEXC it is quoted as ALPH/USDT) MEXC+1
‚Ä¢ API endpoint: The Spot V3 REST endpoint for klines is:

GET https://api.mexc.com/api/v3/klines

MEXC+1
‚Ä¢ Required parameters:
‚Ä¢ symbol ‚Äî e.g., "ALPHUSDT" (no slash)
‚Ä¢ interval ‚Äî one of the allowed intervals: 1m, 5m, 15m, 30m, 60m, 4h, 1d, 1W, 1M MEXC+1
‚Ä¢ Optional: startTime, endTime, limit (how many bars you want) mexcdevelop.github.io+1

üßÆ Example request
If you want the 15-minute candles for ALPH/USDT, you might make an HTTP GET like:

https://api.mexc.com/api/v3/klines?symbol=ALPHUSDT&interval=15m&limit=100
This will return an array of candles, each candle with open time, open price, high, low, close, volume, etc. MEXC

üîÅ Example response snippet
Each item might look like (simplified):

[
  1640804880000,  // open time (ms since epoch)
  "0.300",        // open price
  "0.305",        // high price
  "0.295",        // low price
  "0.302",        // close price
  "1234.56",      // volume
  1640804940000,  // close time
  "some_amount",  // quote volume
  ...             // (other fields depending on API)
]

üß† Tips / things to watch
‚Ä¢ Make sure the symbol exactly matches what MEXC uses (case matters, no slash).
‚Ä¢ The interval string must match one of the listed intervals. If you try something like ‚Äú1h‚Äù or ‚Äúhour1‚Äù and it‚Äôs not allowed, you‚Äôll get an error. (There‚Äôs a known issue about ‚Äú1h‚Äù interval causing Invalid interval error on MEXC SDK). GitHub
‚Ä¢ Time fields are in milliseconds since epoch in most cases, so convert accordingly.
‚Ä¢ If you need real-time updates instead of REST polling, you can use the WebSocket stream for klines: e.g. channel "spot@public.kline.v3.api.pb@<symbol>@<interval>". MEXC+1

If you like, I can show you a ready-to-use code snippet (in Python or JavaScript) for fetching the ALPH/USDT k-line data from MEXC. Would you like that?
You said:
tell me everything about that i need to know to make sure i can fetch data smoothly
ChatGPT said:
Perfect ‚Äî let‚Äôs break it down step by step so you can fetch MEXC ALPH k-line (candlestick) data smoothly, without running into common problems. I‚Äôll cover REST, WebSocket, rate limits, time conversions, and gotchas.

1Ô∏è‚É£ API Endpoint (REST)
URL:

https://api.mexc.com/api/v3/klines
Required Parameters:
Parameter	Description
symbol	Trading pair, e.g., ALPHUSDT (no slash)
interval	Kline interval: 1m, 5m, 15m, 30m, 1h, 4h, 1d, 1W, 1M
limit (optional)	Number of candles returned, max 1000 per request
startTime / endTime (optional)	Unix timestamp in ms, for historical data
Example: Fetch last 100 candles of 15-minute ALPH/USDT:

https://api.mexc.com/api/v3/klines?symbol=ALPHUSDT&interval=15m&limit=100

2Ô∏è‚É£ Response Structure
Each candle comes as an array:

[
  [
    1640804880000,  // Open time (ms since epoch)
    "0.300",        // Open
    "0.305",        // High
    "0.295",        // Low
    "0.302",        // Close
    "1234.56",      // Volume
    1640804940000,  // Close time
    "some_amount",  // Quote asset volume
    "X",            // Number of trades
    "Y",            // Taker buy base asset volume
    "Z",            // Taker buy quote asset volume
    "0"             // Ignore
  ]
]
üí° Tip: Convert open time and close time from milliseconds to human-readable format.

3Ô∏è‚É£ Intervals / Allowed Values
‚Ä¢ 1m, 5m, 15m, 30m ‚Üí intraday
‚Ä¢ 1h, 4h ‚Üí longer intraday
‚Ä¢ 1d, 1W, 1M ‚Üí daily, weekly, monthly
‚ö†Ô∏è Case-sensitive, exact match is required.

4Ô∏è‚É£ Rate Limits
‚Ä¢ Public REST endpoints: ~ 20 requests/sec per IP
‚Ä¢ Keep limit high (up to 1000) to reduce requests for historical data.
‚Ä¢ Use WebSocket for real-time updates to avoid REST polling limits.

5Ô∏è‚É£ Historical Data Fetching Tips
‚Ä¢ Always fetch using startTime and endTime if you need large history.
‚Ä¢ Max candles per request is 1000. If you need more, loop using startTime = last_candle_time + interval_ms.
‚Ä¢ Time conversion: MEXC uses milliseconds, while JS Date uses ms too ‚Äî easy.

6Ô∏è‚É£ Real-Time Updates (WebSocket)
MEXC supports spot WebSocket streams for kline updates:
‚Ä¢ Endpoint:

wss://wbs.mexc.com/ws
‚Ä¢ Subscribe to a kline channel:

{
  "method": "sub.deal",
  "params": {
    "symbol": "ALPHUSDT",
    "channel": "spot@public.kline.v3.api.pb@15m"
  },
  "id": 1
}
‚Ä¢ You receive every new 15-minute candle as it updates.
üí° Tip: Use WebSocket if you want live charts or alerts.

7Ô∏è‚É£ Common Gotchas
1. Symbol format: Always ALPHUSDT ‚Äî no slash.
2. Interval mismatch: Only allowed strings accepted.
3. Time conversion: REST timestamps in milliseconds; convert for loops.
4. Limits: REST max 1000 candles; plan pagination if fetching large history.
5. Network errors: Retry on failure (like 500 or 429).
6. WebSocket reconnection: Always implement auto-reconnect.

8Ô∏è‚É£ Recommended Approach for Smooth Data
‚Ä¢ Historical data ‚Üí REST (with limit, startTime, endTime)
‚Ä¢ Live updates ‚Üí WebSocket
‚Ä¢ Caching ‚Üí Store last candle locally, update only new candles
‚Ä¢ Error handling ‚Üí Retry logic with exponential backoff

If you want, I can make a ready-to-use TypeScript example that fetches ALPH/USDT klines from MEXC REST and WebSocket, handles rate limits, and converts timestamps automatically ‚Äî this will be plug-and-play for your charts.
Do you want me to do that?
You said:
i meant i only want to display top 25 coins that r having highest price % change that are in spot
ChatGPT said:
Good work ‚Äî yes you can display the top‚ÄØ25 spot‚Äëcoins with the highest 24‚ÄØh %‚Äëprice change on MEXC Global (MEXC). I‚Äôll walk you through everything you need to know ‚Äî what endpoints to use, how to filter & sort, what criteria to apply ‚Äî so you can reliably fetch and display this list in your site/app.

‚úÖ What you need to fetch
1. API endpoint for market data (spot tickers)
According to the docs: ‚Äú24‚ÄØhr Ticker Price Change Statistics‚Äù endpoint is available. GitHub+2Mexc Develop+2
Also, general market‚Äëdata endpoints list is here: MEXC+1
2. Fields to pull
For each symbol you‚Äôll want at least:
‚Ä¢ Symbol (e.g., ALPHUSDT)
‚Ä¢ 24h price change % (or absolute change + compute % if only absolute is available)
‚Ä¢ Spot status (is spot trading allowed)
‚Ä¢ Possibly volume, to ensure the pair is sufficiently liquid
‚Ä¢ Quote asset (probably USDT or USDC) so you‚Äôre comparing like‚Äëpairs
3. Filtering
‚Ä¢ Only include pairs where spot trading is allowed. You‚Äôll check isSpotTradingAllowed from ‚ÄúExchange Information‚Äù endpoint. MEXC+1
‚Ä¢ Possibly exclude pairs with very low volume or weird quote assets (optional but helps quality).
‚Ä¢ Only include pairs you care about (for example only USDT quote).
4. Sorting
‚Ä¢ Sort all eligible pairs by 24h % price change descending (highest positive % first)
‚Ä¢ Then take the top‚ÄØ25.
5. Display
‚Ä¢ For your website/app show symbol, current price, price change %, and maybe volume & last update time.
‚Ä¢ Update frequently (e.g., every 1‚Äë5 minutes) since this is live data.

‚öôÔ∏è Implementation Steps (in simple terms)
1. Fetch list of all symbols + info
Use the ‚ÄúExchange Information‚Äù endpoint to get all trading pairs and filter to those where isSpotTradingAllowed = true.
Example: /api/v3/exchangeInfo or whatever is documented in the spot‚ÄØv3 docs.
2. Fetch 24h stats for each symbol
Use endpoint /api/v3/ticker/24hr (or similar) that returns price change % for given symbol. According to SDK docs: client.ticker24hr(symbol?: string) is available. GitHub
You might fetch for all symbols (if API supports bulk) or loop through the symbol list.
3. Filter and sort
‚Ä¢ From the results, keep only those with spot allowed.
‚Ä¢ Ensure quote asset = USDT (or whichever you want) if you only want consistency.
‚Ä¢ Sort by ‚Äúprice change %‚Äù descending.
‚Ä¢ Keep first 25.
4. Display data
‚Ä¢ Update your UI/table accordingly with top‚ÄØ25.
‚Ä¢ Maybe include time stamp of fetch, current price, % change, volume.
5. Scheduling/refresh
‚Ä¢ Because markets move fast, set a refresh interval (e.g., every 2‚Äë5 minutes).
‚Ä¢ Handle API rate limits: don‚Äôt fire too many calls too quickly.

üß† Important Things / Gotchas
‚Ä¢ Rate limits: Public endpoints allow many calls but don‚Äôt abuse them.
‚Ä¢ Bulk vs individual calls: If you loop over thousands of symbols one‚Äëby‚Äëone you‚Äôll hit limits. Check if there is an endpoint returning stats for all symbols at once.
‚Ä¢ Spot vs futures confusion: Make sure you‚Äôre fetching spot only, not futures.
‚Ä¢ Symbols format: E.g., ALPHUSDT, not ALPH/USDT.
‚Ä¢ Time for refresh: Very high volatility means your top‚ÄØ25 may change quickly.
‚Ä¢ Volume/liquidity: Some coins may show huge % change but very low volume (risky). Consider minimum volume threshold.
‚Ä¢ Quotes: Different pairs (USDT, USDC, BTC) have different behaviours; better to keep quote consistent.
‚Ä¢ Display logic: Make sure numeric formatting (e.g., +12.34‚ÄØ%) is clear to your audience.
‚Ä¢ Error handling: If an API call fails or returns partial data, you should degrade gracefully (e.g., show ‚Äúdata unavailable‚Äù).
‚Ä¢ Sorting tie‚Äëbreakers: If two coins have same % change, you might sort by volume.

üéØ Example Pseudocode (JavaScript/TypeScript)

async function fetchTopGainers() {
  // 1. Get exchange info
  const infoResp = await fetch('https://api.mexc.com/api/v3/exchangeInfo');
  const info = await infoResp.json();
  const spotSymbols = info.symbols.filter(s => s.isSpotTradingAllowed === true && s.quoteAsset === 'USDT');
// 2. Get 24h stats for all symbols at once (if possible)
  const statsResp = await fetch('https://api.mexc.com/api/v3/ticker/24hr');
  const stats = await statsResp.json();  // array of { symbol, priceChangePercent, volume, lastPrice, ... }
// 3. Filter to only spotSymbols
  const eligible = stats.filter(s => spotSymbols.some(sp => sp.symbol === s.symbol));
// 4. Sort by priceChangePercent descending
  eligible.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
// 5. Take top 25
  const top25 = eligible.slice(0, 25);
// 6. Display or return
  return top25.map(s => ({
    symbol: s.symbol,
    price: s.lastPrice,
    changePct: s.priceChangePercent,
    volume: s.volume
  }));
}
You can then schedule fetchTopGainers() every few minutes, and update your website UI accordingly.

If you like, I can provide a full working code snippet (in JavaScript or Python) tailored for your website (which you said uses HTML/JS) that fetches and displays the top‚ÄØ25 gainers from MEXC. Would you like that?
Is this conversation helpful so far?



ChatGPT can make mistakes. Check important info.

From <https://chatgpt.com/c/6902884c-edc4-8320-a5e4-81c5e0307760> 
